import './style.css'
import { AudioManager } from './audio/AudioManager'
import { ThreeVisualizer } from './graphics/ThreeVisualizer'
import { MidiManager } from './audio/MidiManager'
import { PersistenceManager } from './system/PersistenceManager'

// --- HTML Structure (Simplified for Sample Launcher) ---
document.querySelector<HTMLDivElement>('#app')!.innerHTML = `
  <div class="app-shell">
    
    <!-- Top Row Buttons -->
    <div class="header-row">
        <button id="init-btn" class="btn-retro">PWR</button>
    </div>
    
    <input type="file" id="kit-file-input" multiple accept="audio/*" style="display:none">

    <!-- The Screen (Subdivided) -->
    <div class="screen-container">
        
        <!-- 1. Top: Sliders -->
        <div class="screen-sliders">
            <div class="slider-group">
                <span class="slider-label">VOL</span>
                <input type="range" class="retro-slider" id="sl-vol" min="0" max="100" value="80">
            </div>
            <div class="slider-group">
                <span class="slider-label">DIST</span>
                <input type="range" class="retro-slider" id="sl-dist" min="0" max="100" value="0">
            </div>
            <div class="slider-group">
                <span class="slider-label">FILT</span>
                <input type="range" class="retro-slider" id="sl-filt" min="0" max="100" value="100">
            </div>
            <div class="slider-group">
                <span class="slider-label">RES</span>
                <input type="range" class="retro-slider" id="sl-res" min="0" max="100" value="0">
            </div>
        </div>

        <!-- 2. Middle: Visualizer -->
        <div class="screen-visualizer">
            <canvas id="webgpu-canvas" width="800" height="600"></canvas>
        </div>

        <!-- 3. Bottom: Terminal Log -->
        <div class="screen-terminal" id="status-log">
            SYSTEM READY.
        </div>
    </div>

    <!-- Utility Bar (Reduced) -->
    <div class="transport-bar">
        <div class="transport-group">
             <button id="load-kit-btn" class="btn-retro btn-small">LOAD</button>
             <button id="clear-kit-btn" class="btn-retro btn-small">CLR</button>
             <button id="metro-btn" class="btn-retro btn-small">METRO</button>
             <button id="mic-btn" class="btn-retro btn-small">MIC</button>
        </div>
        <div class="transport-group">
             <button id="bpm-minus" class="btn-retro btn-small">-</button>
             <div class="bpm-display" id="bpm-area">BPM120</div>
             <button id="bpm-plus" class="btn-retro btn-small">+</button>
        </div>
    </div>

    <!-- Pad Grid (Dynamic) -->
    <div class="pad-grid" id="pad-container">
        <!-- Generated by JS -->
    </div>
    
  </div>
`

// --- References ---
const initButton = document.querySelector<HTMLButtonElement>('#init-btn')!;
const loadKitBtn = document.querySelector<HTMLButtonElement>('#load-kit-btn')!;
const clearKitBtn = document.querySelector<HTMLButtonElement>('#clear-kit-btn')!;
const kitInput = document.querySelector<HTMLInputElement>('#kit-file-input')!;
const metroButton = document.querySelector<HTMLButtonElement>('#metro-btn')!;
const bpmMinus = document.querySelector<HTMLButtonElement>('#bpm-minus')!;
const bpmPlus = document.querySelector<HTMLButtonElement>('#bpm-plus')!;
const micButton = document.querySelector<HTMLButtonElement>('#mic-btn')!;
const bpmArea = document.querySelector<HTMLDivElement>('#bpm-area')!;
const statusLog = document.querySelector<HTMLDivElement>('#status-log')!; // Internal Log
const canvas = document.querySelector<HTMLCanvasElement>('#webgpu-canvas')!;
const padContainer = document.querySelector<HTMLDivElement>('#pad-container')!;

// --- Systems ---
const audioManager = new AudioManager();
const visualizer = new ThreeVisualizer();
const midiManager = new MidiManager();
const persistence = new PersistenceManager(); // NEW


// --- State ---
let isSystemReady = false;
let isMetronomeOn = false;
let isMicMode = false;
let currentBpm = 120;
let tapTimes: number[] = [];

// --- 16 Pad Configuration ---
// Default samples removed as per user request. Pads start empty.

// Visual Layout (bottom-to-top):
// 13 14 15 16  (MIDI 60 61 62 63)
//  9 10 11 12  (MIDI 56 57 58 59)
//  5  6  7  8  (MIDI 52 53 54 55)
//  1  2  3  4  (MIDI 48 49 50 51)
// 16 Pad Configuration (Fixed MIDI 48-63)
// 8 Columns x 2 Rows
// Row 2 (Top): Pads 9-16 (MIDI 56-63)
// Row 1 (Bottom): Pads 1-8 (MIDI 48-55)

const PAD_CONFIG: { id: string, key: string, midi: number }[] = [];
const BASE_MIDI = 48; // Back to C3
const ROWS = 4;
const COLS = 4;


for (let row = ROWS; row >= 1; row--) {
  for (let col = 1; col <= COLS; col++) {
    const rowIndex = row - 1;
    const linearPadNum = (rowIndex * COLS) + col;
    const midiNote = BASE_MIDI + (linearPadNum - 1); // 48-63

    PAD_CONFIG.push({
      id: `pad${linearPadNum}`,
      key: '',
      midi: midiNote
    });
  }
}

// Lookup Maps
const KEY_TO_PAD: Record<string, string> = {}; // 'q' -> 'kick2'
const MIDI_TO_PAD: Record<number, string> = {}; // 48 -> 'pad1'

PAD_CONFIG.forEach(p => {
  KEY_TO_PAD[p.key.toLowerCase()] = p.id;
  MIDI_TO_PAD[p.midi] = p.id;
});

// --- Initialization ---

function generatePads() {
  padContainer.innerHTML = '';
  PAD_CONFIG.forEach((pad) => {
    const btn = document.createElement('button');
    btn.className = 'drum-pad empty'; // Start as empty
    btn.id = `pad-${pad.id}`;
    btn.dataset.sample = pad.id;
    // btn.disabled = true; // REMOVED: prevents events

    // Extract pad number from ID (e.g., "pad13" -> "13")
    const padNumber = pad.id.replace('pad', '');

    // Pad Label
    btn.innerHTML = `
            ${padNumber}
            <span class="key-hint">${pad.key}</span>
        `;

    // --- Touch/Click events with MIC Mode Recording ---
    const handlePadClick = async (e: Event) => {
      e.preventDefault();

      // if (btn.disabled) return; // REMOVED

      // If NOT in mic mode AND empty, do nothing
      if (!isMicMode && btn.classList.contains('empty')) return;
      if (isMicMode) {
        // Start countdown and recording
        btn.classList.add('recording');
        let countdown = 3;
        logStatus(`RECORDING IN ${countdown}...`);

        const countdownInterval = setInterval(() => {
          if (!isMicMode) {
            clearInterval(countdownInterval);
            btn.classList.remove('recording');
            logStatus('MIC MODE OFF');
            return;
          }
          countdown--;
          if (countdown > 0) {
            logStatus(`RECORDING IN ${countdown}...`);
          }
        }, 1000);

        // Wait 3 seconds then start recording
        setTimeout(async () => {
          clearInterval(countdownInterval);
          if (!isMicMode) {
            btn.classList.remove('recording');
            return;
          }
          logStatus('RECORDING...');

          try {
            await audioManager.startMicRecording();

            // Auto-stop after 10 seconds or wait for second click
            const stopRecording = async () => {
              btn.classList.remove('recording');
              try {
                const result = await audioManager.stopMicRecording();
                if (result) {
                  const { buffer, blob } = result;
                  await audioManager.loadRecordedSample(pad.id, buffer);

                  // SAVE SAMPLE TO DB
                  await persistence.saveSample(pad.id, blob);
                  console.log(`[Main] Saved recorded sample to ${pad.id}`);

                  btn.classList.remove('empty'); // Enable
                  btn.style.borderColor = "#fff";
                  setTimeout(() => btn.style.borderColor = "", 200);
                  logStatus(`RECORDED > PAD ${padNumber}`);
                }
              } catch (err) {
                logStatus('RECORDING ERROR');
                console.error(err);
              }
              btn.removeEventListener('click', stopRecording);
            };

            // Click again to stop
            btn.addEventListener('click', stopRecording, { once: true });

            // Auto-stop after 10 seconds
            setTimeout(stopRecording, 10000);

          } catch (err) {
            logStatus('MIC ACCESS DENIED');
            console.error(err);
            btn.classList.remove('recording');
          }
        }, 3000);

      } else {
        // Normal mode - just trigger the voice
        // (Only if not disabled)
        triggerVoice(pad.id);
      }
    };

    btn.addEventListener('mousedown', handlePadClick);
    btn.addEventListener('touchstart', handlePadClick);


    // Visual feedback for bank selector pads (REMOVED)

    // --- Drag & Drop ---
    btn.addEventListener('dragover', (e) => {
      e.preventDefault(); // allow drop
      e.dataTransfer!.dropEffect = 'copy';
      btn.classList.add('drag-over');
    });

    btn.addEventListener('dragleave', (e) => {
      e.preventDefault();
      btn.classList.remove('drag-over');
    });

    btn.addEventListener('drop', async (e) => {
      e.preventDefault();

      // If multiple files, it's a Kit Load -> Let it bubble to container
      if (e.dataTransfer && e.dataTransfer.files.length > 1) {
        return; // Allow bubble
      }

      // Single File -> Handle here and Stop Propagation
      e.stopPropagation();
      btn.classList.remove('drag-over');

      if (e.dataTransfer && e.dataTransfer.files.length > 0) {
        const file = e.dataTransfer.files[0];
        if (file.type.startsWith('audio/')) {
          logStatus(`LOADING ${file.name.toUpperCase()}...`);
          try {
            await audioManager.loadUserSample(pad.id, file);

            // SAVE TO DB
            await persistence.saveSample(pad.id, file);
            console.log(`[Main] Saved ${pad.id} to DB`);

            btn.classList.remove('empty');
            // flash success
            btn.style.borderColor = "#fff";
            setTimeout(() => btn.style.borderColor = "", 200);
            logStatus(`LOADED > PAD ${padNumber}`);
          } catch (err) {
            logStatus('ERROR LOADING FILE.');
            console.error(err);
          }
        } else {
          logStatus('NOT AN AUDIO FILE.');
        }
      }
    });

    padContainer.appendChild(btn);
  });
}

// Generate immediately for layout
generatePads();

// --- Main Init ---
initButton.addEventListener('click', async () => {
  if (isSystemReady) return;
  initButton.disabled = true;
  logStatus('INITIALIZING...');

  try {
    // 1. Init Persistence
    console.log('[Init] 1. Persistence...');
    await persistence.init(); // NEW

    console.log('[Init] 2. Audio...');
    await audioManager.init();

    // Init Visualizer
    console.log('[Init] 3. Visualizer...');
    visualizer.init(canvas);
    visualizer.setDataProvider(() => audioManager.getAllWaveforms());
    visualizer.start();

    console.log('[MAIN] Visualizer initialized.');
    console.log('[Init] 4. MIDI...');

    // Race MIDI init against a 2-second timeout to prevent freeze
    const midiPromise = midiManager.init();
    const timeoutPromise = new Promise<boolean>((resolve) =>
      setTimeout(() => {
        console.warn('[Init] MIDI init timed out. Continuing without MIDI.');
        resolve(false);
      }, 2000)
    );

    await Promise.race([midiPromise, timeoutPromise]);

    // Bindings
    midiManager.setNoteOnCallback(handleMidiNote);
    midiManager.setCcCallback(handleMidiCC); // New CC Handler
    audioManager.setWorkletCallback(handleWorkletMessage); // Only logs now

    isSystemReady = true;

    // 2. Load Settings from DB
    console.log('[Init] 5. Load Settings...');
    await loadSettings();

    // 3. Load Samples (DB or Default)
    console.log('[Init] 6. Load Samples...');
    await loadAllSamples();

    // setupDragAndDrop(); // Redundant, handled in generatePads

    logStatus('SYSTEM READY');
    initButton.textContent = "ON";
    initButton.classList.add('active');

  } catch (err) {
    console.error(err);
    logStatus('ERROR.');
  }
});

async function loadSettings() {
  try {
    const settings = await persistence.loadAllSettings();
    console.log('[Main] Settings loaded:', settings);

    // Apply Global Settings
    if (settings.bpm) {
      currentBpm = settings.bpm;
      updateBpmUI(currentBpm);
      audioManager.setBpm(currentBpm);
    }

    // Apply Sliders
    const sliderIds = ['sl-vol', 'sl-dist', 'sl-filt', 'sl-res'];
    sliderIds.forEach(id => {
      if (settings[id] !== undefined) {
        const val = settings[id];
        const slider = document.getElementById(id) as HTMLInputElement;
        if (slider) {
          slider.value = val.toString();
          // Trig change evt?
          // Manually trigger callback
          if (id === 'sl-vol') audioManager.setMasterVolume(val / 100);
          if (id === 'sl-dist') audioManager.setDistortion(val);
          if (id === 'sl-filt') audioManager.setFilterCutoff(val);
          if (id === 'sl-res') audioManager.setFilterResonance(val);
        }
      }
    });

    // Sync Visuals
    updateVisualizerEffects();

  } catch (err) {
    console.warn('Failed to load settings', err);
  }
}

// --- Helper ---
function logStatus(text: string) {
  if (statusLog) statusLog.textContent = "> " + text;
}

// --- Effects & Metronome ---

metroButton.addEventListener('click', () => {
  if (!isSystemReady) return;
  isMetronomeOn = !isMetronomeOn;
  audioManager.toggleMetronome(isMetronomeOn);
  metroButton.classList.toggle('active', isMetronomeOn);
  logStatus(isMetronomeOn ? 'METRONOME ON' : 'METRONOME OFF');
});

micButton.addEventListener('click', () => {
  if (!isSystemReady) return;
  isMicMode = !isMicMode;
  micButton.classList.toggle('active', isMicMode);
  logStatus(isMicMode ? 'MIC MODE ON' : 'MIC MODE OFF');

  if (isMicMode) {
    audioManager.prepareMicrophone();
  }
});


// --- BPM Logic ---

function updateBpmUI(bpm: number) {
  if (bpmArea) {
    bpmArea.textContent = `BPM${bpm.toString().padStart(3, '0')}`;
  }
}

bpmMinus.addEventListener('click', () => changeBpm(-1));
bpmPlus.addEventListener('click', () => changeBpm(1));

function changeBpm(delta: number) {
  if (!isSystemReady) return;
  let newBpm = currentBpm + delta;
  if (newBpm < 40) newBpm = 40;
  if (newBpm > 240) newBpm = 240;

  currentBpm = newBpm;
  audioManager.setBpm(currentBpm);
  updateBpmUI(currentBpm);
  persistence.saveSetting('bpm', currentBpm);
}

// --- Tap Tempo Logic ---
bpmArea.addEventListener('click', () => {
  if (!isSystemReady) return;

  const now = Date.now();
  tapTimes.push(now);

  // Only keep taps within last 2 seconds
  tapTimes = tapTimes.filter(t => now - t < 2000);

  if (tapTimes.length > 1) {
    // Calculate average interval
    let sumIntervals = 0;
    for (let i = 1; i < tapTimes.length; i++) {
      sumIntervals += (tapTimes[i] - tapTimes[i - 1]);
    }
    const avgInterval = sumIntervals / (tapTimes.length - 1);
    const newBpm = Math.round(60000 / avgInterval);

    // Clamp sensible BPM
    if (newBpm >= 40 && newBpm <= 240) {
      currentBpm = newBpm;
      audioManager.setBpm(currentBpm);
      updateBpmUI(currentBpm);
      logStatus(`TAP BPM: ${currentBpm}`);

      // Save
      persistence.saveSetting('bpm', currentBpm);
    }
  } else {
    logStatus('TAP...');
  }
});

function handleWorkletMessage(data: any) {
  if (data.type === 'LOG') {
    console.log(data.payload);
  }
}

const ccMap = {
  24: { id: '#sl-vol', fn: (val: number) => audioManager.setMasterVolume(val / 100) },
  25: { id: '#sl-dist', fn: (val: number) => audioManager.setDistortion(val) },
  26: { id: '#sl-filt', fn: (val: number) => audioManager.setFilterCutoff(val) },
  27: { id: '#sl-res', fn: (val: number) => audioManager.setFilterResonance(val) }
};

function handleMidiCC(cc: number, value: number) {
  // CC value is 0-127. Map to 0-100 for sliders.
  const normalized = Math.round((value / 127) * 100);

  // Update UI and Audio
  // Vol (24), Dist (25), Filt (26), Res (27)
  if (ccMap[cc as keyof typeof ccMap]) {
    const mapping = ccMap[cc as keyof typeof ccMap];
    const slider = document.querySelector<HTMLInputElement>(mapping.id);
    if (slider) {
      slider.value = normalized.toString();
      mapping.fn(normalized);
      logStatus(`CC${cc}: ${normalized}%`);

      updateVisualizerEffects();

      // Save Setting (Extract ID as key)
      const key = mapping.id.replace('#', '');
      persistence.saveSetting(key, normalized);
    }
  }
}

// --- Effects & Visual Sync Helper ---
function updateVisualizerEffects() {
  const distSlider = document.getElementById('sl-dist') as HTMLInputElement;
  const filtSlider = document.getElementById('sl-filt') as HTMLInputElement;
  if (distSlider && filtSlider) {
    visualizer.setEffects(parseInt(distSlider.value), parseInt(filtSlider.value));
  }
}

// --- Slider Input (Visual + DSP + MIDI Out) ---
function setupSlider(id: string, cc: number, callback: (val: number) => void) {
  document.querySelector<HTMLInputElement>(id)?.addEventListener('input', (e: Event) => {
    const val = parseInt((e.target as HTMLInputElement).value); // 0-100
    callback(val);

    // Update Visualizer Simulation
    updateVisualizerEffects();

    // MIDI Out (0-100 -> 0-127)
    const midiVal = Math.round((val / 100) * 127);
    midiManager.sendCC(cc, midiVal);

    // Log
    const label = id.replace('#sl-', '').toUpperCase();
    logStatus(`${label}: ${val}%`);

    // Save
    persistence.saveSetting(id.replace('#', ''), val);
  });
}

setupSlider('#sl-vol', 24, (val) => audioManager.setMasterVolume(val / 100));
setupSlider('#sl-dist', 25, (val) => audioManager.setDistortion(val));
setupSlider('#sl-filt', 26, (val) => audioManager.setFilterCutoff(val));
setupSlider('#sl-res', 27, (val) => audioManager.setFilterResonance(val));


// --- Input Handling ---

function triggerVoice(id: string, velocity: number = 1.0) {
  if (!isSystemReady) return;
  audioManager.playSample(id, velocity);

  const pad = document.getElementById(`pad-${id}`);
  if (pad) {
    pad.classList.add('active');
    setTimeout(() => pad.classList.remove('active'), 80);
  }

  logStatus(`${id.toUpperCase()} (v${Math.round(velocity * 127)})`);
}

function handleMidiNote(note: number, velocity: number) {
  const sampleId = MIDI_TO_PAD[note];
  if (sampleId) {
    // Normalize velocity
    const normVelocity = velocity / 127.0;
    triggerVoice(sampleId, normVelocity);
  }
}

window.addEventListener('keydown', (e) => {
  if (e.repeat) return;

  // Check for pad key
  const padId = KEY_TO_PAD[e.key.toLowerCase()];
  if (padId) {
    triggerVoice(padId);
    return;
  }
});

// --- Render Loop ---
// Render Loop handled by ThreeVisualizer internal loop

// --- Initialization Helpers ---

async function loadAllSamples() {
  logStatus('LOADING SAMPLES...');

  // Parallel loading? Iterate refs
  // We need to check DB first for each.

  try {
    const promises = PAD_CONFIG.map(async (pad) => {
      // Check DB
      const blob = await persistence.loadSample(pad.id);

      if (blob) {
        console.log(`[Main] Loading ${pad.id} from DB`);
        const file = new File([blob], "saved_sample.wav", { type: "audio/wav" });
        await audioManager.loadUserSample(pad.id, file);

        // Enable Pad if loaded
        const btn = document.getElementById(`pad-${pad.id}`) as HTMLButtonElement;
        if (btn) btn.classList.remove('empty');
      }
    });

    await Promise.all(promises);

    logStatus('SAMPLES LOADED');
  } catch (err) {
    console.error('Failed to load samples:', err);
    logStatus('LOAD ERROR');
  }
}

// --- Drag & Drop (Global Kit Load) ---
// Allow dropping a group of files onto the main container to load a "Kit"
padContainer.addEventListener('dragover', (e) => {
  e.preventDefault();
  e.dataTransfer!.dropEffect = 'copy';
  padContainer.classList.add('drag-over-container');
});

padContainer.addEventListener('dragleave', (e) => {
  e.preventDefault();
  padContainer.classList.remove('drag-over-container');
});

padContainer.addEventListener('drop', async (e) => {
  e.preventDefault();
  padContainer.classList.remove('drag-over-container');

  if (!e.dataTransfer || e.dataTransfer.files.length === 0) return;

  const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('audio/'));

  // sorting logic: "01_kick.wav" -> "02_snare.wav"
  // Use numeric collation for "1" vs "10" correctness
  files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));

  if (files.length > 0) {
    logStatus(`DETECTED KIT: ${files.length} SAMPLES`);

    // Map first 16 files to pads 1-16
    // We need to find the pad ID for index 1..16
    // PAD_CONFIG might be in any order, so we lookup by ID

    const count = Math.min(files.length, 16);
    for (let i = 0; i < count; i++) {
      const padNum = i + 1; // 1-based
      const padId = `pad${padNum}`;
      const file = files[i];

      // Visual feedback
      const btn = document.querySelector<HTMLButtonElement>(`#pad-${padId}`);
      if (btn) {
        btn.classList.add('loading');
      }

      try {
        await audioManager.loadUserSample(padId, file);

        // SAVE TO DB
        await persistence.saveSample(padId, file);

        if (btn) {
          btn.classList.remove('empty');
          btn.classList.remove('loading');
          // Flash
          btn.style.borderColor = "#0f0";
          setTimeout(() => btn.style.borderColor = "", 300);
        }
      } catch (err) {
        console.error(`Failed to load kit sample ${padId}`, err);
      }
    }
    logStatus(`KIT LOADED (${count} SAMPLES)`);
  }
});

// --- Sample Management Logic ---

loadKitBtn.addEventListener('click', () => {
  if (!isSystemReady) return;
  kitInput.click();
});

clearKitBtn.addEventListener('click', async () => {
  if (!isSystemReady) return;
  if (confirm('CLEAR ALL SAMPLES?')) {
    logStatus('CLEARING DATA...');
    await persistence.clearDatabase();

    // Reset UI
    PAD_CONFIG.forEach(pad => {
      const btn = document.getElementById(`pad-${pad.id}`) as HTMLButtonElement;
      if (btn) {
        btn.classList.add('empty');
        btn.style.borderColor = "";
      }
    });

    logStatus('SYSTEM CLEARED.');
  }
});

kitInput.addEventListener('change', async (e) => {
  const files = (e.target as HTMLInputElement).files;
  if (!files || files.length === 0) return;

  const fileList = Array.from(files).filter(f => f.type.startsWith('audio/'));
  fileList.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));

  if (fileList.length > 0) {
    logStatus(`LOADING KIT (${fileList.length})...`);
    const count = Math.min(fileList.length, 16);

    for (let i = 0; i < count; i++) {
      const padNum = i + 1;
      const padId = `pad${padNum}`;
      const file = fileList[i];

      try {
        // UI Loading state
        const btn = document.getElementById(`pad-${padId}`) as HTMLButtonElement;
        if (btn) btn.style.borderColor = "#9bbc0f"; // Loading color

        await audioManager.loadUserSample(padId, file);
        await persistence.saveSample(padId, file);

        if (btn) {
          btn.classList.remove('empty');
          btn.style.borderColor = "";
        }
      } catch (err) {
        console.error(`Failed to load ${padId}`, err);
      }
    }
    logStatus('KIT LOADED.');
  }
  kitInput.value = '';
});

// --- Window Resize Handling ---
window.addEventListener('resize', () => {
  if (canvas) {
    visualizer.resize(canvas.clientWidth, canvas.clientHeight);
  }
});
